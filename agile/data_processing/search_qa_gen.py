import sys
sys.path.append('..')
import argparse
import json
import os
import random
import time
from client import SQLClient
from models import AzureClient
from tqdm import tqdm

sql2question_prompt = """Please generate a natural language question for the following SQL query in the tone of a product buyer asking customer service. More diverse and life oriented expressions are preferred. Don't be too polite.
Units: {}

SQL: SELECT product_id FROM `headphones` ORDER BY standby_time DESC limit 1;
NL: My device is often left on standby, so I need something that doesn't drain quickly. Show me the product with the longest standby time.

SQL: SELECT product_id FROM `camera_cases` WHERE price < 30 ORDER BY price ASC LIMIT 1;
NL: I'm on a budget here and can't spend more than 30 bucks. Find me the cheapest camera case you got that fits the bill..

SQL: {}
NL: """

sql2question_filter_prompt = """Please determine whether this question is a typical customer might ask while considering a purchase in the category {}. Please output Yes or No.
{}"""

question2sql_prompt = """Generate SQL statement based on the {} products table and questions. Try not use MAX and MIN aggregate functions.
The table field name and optional values are as follows in format field(value1, value2, ...):\n{}
Question: {}
SQL: SELECT product_id FROM {} """


class SearchQAGenerator(object):
    def __init__(self, group):
        self.group = group
        self.dirname = os.path.join('search_qa', group)
        self.azure_client = AzureClient(api_key='')
        self.sql_client = SQLClient(os.path.join('..', 'product_qa.db'))

    def schema2sql(self):
        schema = json.load(open(os.path.join(self.dirname, 'sql_schema.json')))
        sql_set = set() # deduplication
        sqls = []
        while len(sqls) < 1000:
            # number of conditions 0｜1｜2
            cond_mod = random.random()
            cond_num = 0
            if 0.2 < cond_mod <= 0.6:
                cond_num = 1
            elif cond_mod > 0.6:
                cond_num = 2

            # generate the set of conditions
            conds = random.sample(schema, cond_num)
            cond_strs = []
            for i in range(cond_num):
                attr = conds[i]
                attr_mod = random.random()

                if attr["type"] == "comparable":
                    if attr["order"] == "ASC":
                        if random.random() < 0.5:
                            cond_str = " {} < ".format(attr["name"])
                        else:
                            cond_str = " {} <= ".format(attr["name"])
                        if random.random() < 0.1: # generated by aggregate function
                            cond_str += "(SELECT AVG({}) FROM {})".format(attr["name"], self.group) + " "
                        else:
                            cond_str += str(random.choice(attr["value_choices"])) + " "
                    else:
                        if random.random() < 0.5:
                            cond_str = " {} > ".format(attr["name"])
                        else:
                            cond_str = " {} >= ".format(attr["name"])
                        if random.random() < 0.1: # generated by aggregate function
                            cond_str += "(SELECT AVG({}) FROM {})".format(attr["name"], self.group) + " "
                        else:
                            cond_str += str(random.choice(attr["value_choices"])) + " "

                else:
                    if attr_mod  < 1 / 3:
                        if "order" in attr:
                            if attr["order"] == "DESC":
                                choice = attr["value_choices"][-1]
                            else:
                                choice = attr["value_choices"][0]
                        else:
                            choice = random.choice(attr["value_choices"])
                        cond_str = " {} = \"{}\" ".format(attr["name"], choice)
                    elif attr_mod < 2 / 3:
                        if len(attr["value_choices"]) == 2 or attr["double_selection"] == False:
                            cond_str = " {} = \"{}\" ".format(attr["name"], random.choice(attr["value_choices"]))
                        else:
                            if "order" in attr:
                                if attr["order"] == "DESC":
                                    choice = attr["value_choices"][-2:]
                                else:
                                    choice = attr["value_choices"][:2]
                            else:
                                choice = random.sample(attr["value_choices"], 2)
                            cond_str = " {} IN (\"{}\", \"{}\") ".format(attr["name"], *choice)
                    else:
                        if "order" in attr:
                            if attr["order"] == "ASC":
                                choice = attr["value_choices"][-1]
                            else:
                                choice = attr["value_choices"][0]
                        else:
                            choice = random.choice(attr["value_choices"])
                        cond_str = " NOT {} = \"{}\" ".format(attr["name"], choice)

                cond_strs.append(cond_str)

            cond = ""
            if cond_num == 1:
                cond = " WHERE " + cond_strs[0]
            elif cond_num == 2:
                cond = " WHERE " + cond_strs[0] + " AND " + cond_strs[1]

            order_by = random.random()
            if cond_num == 1 and order_by < 0.4 or cond_num == 2 and order_by < 0.6:
                sql = "SELECT product_id FROM `{product}` {cond} LIMIT 1;".format(
                    product=self.group,
                    cond=cond
                )
                sql = " ".join(sql.split())
                answer = "SELECT product_id FROM `{product}` {cond};".format(
                    product=self.group,
                    cond=cond
                )
                answer = " ".join(answer.split())
                if sql in sql_set:
                    continue
                sql_set.add(sql)
                sqls.append({
                    "sql": sql,
                    "answer": answer
                })
                continue

            # generate comparables according to weight
            comparables = []
            for attr in schema:
                if attr["type"] == "comparable":
                    for j in range(attr["weight"]):
                        comparables.append(attr)
            comparable_attr = random.choice(comparables)
            comparable = comparable_attr["name"]
            order = comparable_attr["order"]
            if comparable in cond:
                continue

            sql = "SELECT product_id FROM `{product}` {cond} ORDER BY {comparable} {order} LIMIT 1;".format(
                product=self.group,
                cond=cond,
                comparable=comparable,
                order=order
            )
            sql = " ".join(sql.split())
            if sql in sql_set:
                continue
            sql_set.add(sql)

            answer = "SELECT product_id FROM `{product}` {cond} {comparable} = (SELECT {aggr}({comparable1}) FROM `{product1}` {cond1});".format(
                product=self.group,
                cond="WHERE" if cond == "" else cond + " AND ",
                comparable=comparable,
                aggr="MIN" if order == "ASC" else "MAX",
                comparable1=comparable,
                product1=self.group,
                cond1=cond
            )
            answer = " ".join(answer.split())
            sqls.append({
                "sql": sql,
                "answer": answer
            })

        with open(os.path.join(self.dirname, 'schema2sql.jsonl'), 'w') as f:
            f.write('\n'.join([json.dumps(sql) for sql in sqls]))

    def sql2question(self):
        schema = json.load(open(os.path.join(self.dirname, 'sql_schema.json')))
        units = []
        for i in schema:
            if "unit" in i:
                units.append("the unit of {} is {}".format(i["name"], i["unit"]))

        with open(os.path.join(self.dirname, 'schema2sql.jsonl')) as f, open(os.path.join(self.dirname, 'sql2question.jsonl'), 'w') as f1:
            for line in tqdm(f.readlines()):
                data = json.loads(line)
                while True:
                    try:
                        question = self.azure_client(sql2question_prompt.format(",".join(units), data['sql']), max_tokens=2048)
                        break
                    except:
                        time.sleep(1)
                        continue
                while True:
                    try:
                        check = self.azure_client(sql2question_filter_prompt.format(self.group, question), max_tokens=2048).strip()
                        break
                    except:
                        time.sleep(1)
                        continue
                if "yes" in check.lower():
                    data['question'] = question.strip()
                    f1.write(json.dumps(data) + '\n')
                    f1.flush()

    def question2sql(self):
        template_single = [
            "I've got an option for you.",
            "The product that meets your requirements is as follows.",
            "I found a product that matches your criteria.",
            "The best option for you is:",
            "Here is an option for you:",
            "The product that fits your requirements is:",
            "The product that would suit your preferences is:",
        ]

        schema = json.load(open(os.path.join(self.dirname, 'sql_schema.json')))

        with open(os.path.join("amazon_data", self.group + ".json")) as f:
            asins = [product['asin'] for product in json.load(f)]

        contents = ["product_id"]
        for i in schema:
            if i['type'] == "comparable":
                content = i['name']
            else:
                content = i['name'] + "(" + ", ".join(i['value_choices']) + ")"
            if "unit" in i:
                content += "[unit: {}]".format(i['unit'])
            contents.append(content)

        with open(os.path.join(self.dirname, "sql2question.jsonl")) as f, open(os.path.join(self.dirname, "final.jsonl"), 'w') as f1:
            idx = 0
            for line in tqdm(f.readlines()):
                data = json.loads(line)
                retry = 5 # remove the data after 5 chances
                while retry > 0:
                    retry -= 1

                    gold = self.sql_client.sql_query(data['answer'], self.group)
                    if gold == "err":
                        continue
                    query = question2sql_prompt.format(self.group, " | ".join(contents), data['question'], self.group)

                    while True:
                        try:
                            question2sql = "SELECT product_id FROM `{}` ".format(self.group) + self.azure_client(query, max_tokens=2048)
                            break
                        except:
                            time.sleep(1)
                            pass
                    pred = self.sql_client.sql_query(question2sql, self.group)
                    if len(gold) > 0:
                        if len(pred) != 1:
                            continue
                        if pred[0] not in gold:
                            continue
                        title = self.sql_client.sql_query(data["answer"], self.group, True)
                        template = random.choice(template_single)
                        short_answer = [{"asin": d[0], "title": d[1]} for d in title]
                        long_answer = template + "\n`{}` with asin: {}".format(title[0][1], title[0][0])
                    else:
                        if len(pred) > 0:
                            continue
                        short_answer = []
                        long_answer = "Sorry, we do not have any products that meet your requirements"
                    if random.random() < 0.1: # the answer is directly correct with a slight probability
                        asins_cand = asins
                    else:
                        asins_cand = [asin for asin in asins if asin not in gold]
                    if len(asins_cand) == 0:
                        continue
                    res = {
                        "id": "comparison_qa_" + str(idx),
                        "asin": random.choice(asins_cand),
                        "question": data['question'],
                        "short_answer": short_answer,
                        "long_answer": long_answer,
                        "type": "comparison_qa",
                        "extra_data": {
                            "sql": data["sql"],
                            "answer": data["answer"],
                            "question2sql": question2sql
                        }
                    }
                    idx += 1
                    f1.write(json.dumps(res, ensure_ascii=False) + "\n")
                    f1.flush()
                    break


if __name__ == '__main__':
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('--group', type=str, required=True, help='group name')
    args = arg_parser.parse_args()

    search_qa_generator = SearchQAGenerator(args.group)
    search_qa_generator.schema2sql()
    search_qa_generator.sql2question()
    search_qa_generator.question2sql()
